/*
 * Note: this file originally auto-generated by mib2c
 * using mib2c.iterate.conf
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "xdsl2LineTable.h"
#include "xdslctl_output_parser.h"

#define SET_BIT(buf, bit) ((buf)[(bit) / 8] |= (1 << (7 - ((bit) % 8))))

 /** Initializes the xdsl2LineTable module */
void
init_xdsl2LineTable(void)
{
	/* here we initialize all the tables we're planning on supporting */
	initialize_table_xdsl2LineTable();
}


/** Initialize the xdsl2LineTable table by defining its contents and how it's structured */
void
initialize_table_xdsl2LineTable(void)
{
	const oid xdsl2LineTable_oid[] = { 1,3,6,1,2,1,10,251,1,1,1 };
	const size_t xdsl2LineTable_oid_len = OID_LENGTH(xdsl2LineTable_oid);
	netsnmp_handler_registration* reg;
	netsnmp_iterator_info* iinfo;
	netsnmp_table_registration_info* table_info;

	DEBUGMSGTL(("xdsl2LineTable:init", "initializing table xdsl2LineTable\n"));

	reg = netsnmp_create_handler_registration(
		"xdsl2LineTable", xdsl2LineTable_handler,
		xdsl2LineTable_oid, xdsl2LineTable_oid_len,
		HANDLER_CAN_RWRITE
	);

	table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
	netsnmp_table_helper_add_indexes(table_info,
		ASN_INTEGER,  /* index: ifIndex */
		0);
	table_info->min_column = COLUMN_XDSL2LINECONFTEMPLATE;
	table_info->max_column = COLUMN_XDSL2LINESTATUSACTUALCE;

	iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
	iinfo->get_first_data_point = xdsl2LineTable_get_first_data_point;
	iinfo->get_next_data_point = xdsl2LineTable_get_next_data_point;
	iinfo->table_reginfo = table_info;

	netsnmp_register_table_iterator(reg, iinfo);

	/* Initialise the contents of the table here */
}

/* Typical data structure for a row entry */
struct xdsl2LineTable_entry {
	/* Index values */
	long ifIndex;

	/* Column values */
	char xdsl2LineConfTemplate[MAX_LEN_32];
	size_t xdsl2LineConfTemplate_len;
	char old_xdsl2LineConfTemplate[MAX_LEN_32];
	size_t old_xdsl2LineConfTemplate_len;
	char xdsl2LineConfFallbackTemplate[MAX_LEN_32];
	size_t xdsl2LineConfFallbackTemplate_len;
	char xdsl2LineAlarmConfTemplate[MAX_LEN_32];
	size_t xdsl2LineAlarmConfTemplate_len;
	long xdsl2LineCmndConfPmsf;
	long xdsl2LineCmndConfLdsf;
	long xdsl2LineCmndConfLdsfFailReason;
	long xdsl2LineCmndConfBpsc;
	long xdsl2LineCmndConfBpscFailReason;
	u_long xdsl2LineCmndConfBpscRequests;
	long xdsl2LineCmndAutomodeColdStart;
	long xdsl2LineCmndConfReset;
	char xdsl2LineStatusActTemplate[MAX_LEN_32];
	size_t xdsl2LineStatusActTemplate_len;
	char xdsl2LineStatusXtuTransSys[MAX_LEN_32];
	size_t xdsl2LineStatusXtuTransSys_len;
	long xdsl2LineStatusPwrMngState;
	long xdsl2LineStatusInitResult;
	long xdsl2LineStatusLastStateDs;
	long xdsl2LineStatusLastStateUs;
	char xdsl2LineStatusXtur[MAX_LEN_32];
	size_t xdsl2LineStatusXtur_len;
	char xdsl2LineStatusXtuc[MAX_LEN_32];
	size_t xdsl2LineStatusXtuc_len;
	u_long xdsl2LineStatusAttainableRateDs;
	u_long xdsl2LineStatusAttainableRateUs;
	long xdsl2LineStatusActPsdDs;
	long xdsl2LineStatusActPsdUs;
	long xdsl2LineStatusActAtpDs;
	long xdsl2LineStatusActAtpUs;
	char xdsl2LineStatusActProfile[MAX_LEN_2];
	char xdsl2LineStatusActLimitMask[MAX_LEN_32];
	size_t xdsl2LineStatusActLimitMask_len;
	char xdsl2LineStatusActUs0Mask[MAX_LEN_4];
	size_t xdsl2LineStatusActUs0Mask_len;
	long xdsl2LineStatusActSnrModeDs;
	long xdsl2LineStatusActSnrModeUs;
	u_long xdsl2LineStatusElectricalLength;
	char xdsl2LineStatusTssiDs[MAX_LEN_32];
	size_t xdsl2LineStatusTssiDs_len;
	char xdsl2LineStatusTssiUs[MAX_LEN_32];
	size_t xdsl2LineStatusTssiUs_len;
	char xdsl2LineStatusMrefPsdDs[MAX_LEN_32];
	size_t xdsl2LineStatusMrefPsdDs_len;
	char xdsl2LineStatusMrefPsdUs[MAX_LEN_32];
	size_t xdsl2LineStatusMrefPsdUs_len;
	long xdsl2LineStatusTrellisDs;
	long xdsl2LineStatusTrellisUs;
	u_long xdsl2LineStatusActualCe;

	/* Illustrate using a simple linked list */
	int   valid;
	struct xdsl2LineTable_entry* next;
};

struct xdsl2LineTable_entry* xdsl2LineTable_head;

/* create a new row in the (unsorted) table */
struct xdsl2LineTable_entry* xdsl2LineTable_createEntry(long ifIndex) {
	struct xdsl2LineTable_entry* entry;

	entry = SNMP_MALLOC_TYPEDEF(struct xdsl2LineTable_entry);
	if (!entry)
		return NULL;

	entry->ifIndex = ifIndex;
	entry->next = xdsl2LineTable_head;

	xdsl2LineTable_head = entry;
	return entry;
}

/* remove a row from the table */
void
xdsl2LineTable_removeEntry(struct xdsl2LineTable_entry* entry) {
	struct xdsl2LineTable_entry* ptr, * prev;

	if (!entry)
		return;    /* Nothing to remove */

	for (ptr = xdsl2LineTable_head, prev = NULL;
		ptr != NULL;
		prev = ptr, ptr = ptr->next) {
		if (ptr == entry)
			break;
	}
	if (!ptr)
		return;    /* Can't find it */

	if (prev == NULL)
		xdsl2LineTable_head = ptr->next;
	else
		prev->next = ptr->next;

	SNMP_FREE(entry);   /* XXX - release any other internal resources */
}


/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list*
xdsl2LineTable_get_first_data_point(void** my_loop_context, void** my_data_context, netsnmp_variable_list* put_index_data, netsnmp_iterator_info* mydata)
{
	populate_xdsl2LineTable();

	*my_loop_context = xdsl2LineTable_head;
	return xdsl2LineTable_get_next_data_point(my_loop_context, my_data_context, put_index_data, mydata);
}

static void populate_xdsl2LineTable(void) {
	struct xdsl2LineTable_entry* entry;

	// Free old list if needed
	while (xdsl2LineTable_head) {
		entry = xdsl2LineTable_head;
		xdsl2LineTable_head = entry->next;
		free(entry);
	}

	xdsl_stats_t lines_stats[MAX_XDSL_LINES];
	uint8_t known_lines = get_xdslctl_stats(lines_stats, MAX_XDSL_LINES);
	DEBUGMSGTL(("xdsl2LineTable:populate_xdsl2LineTable", "Read %d xDSL lines\n", known_lines));

	for (int8_t linenum = known_lines - 1; linenum >= 0; linenum--) {
		entry = xdsl2LineTable_createEntry(linenum + BASE_IFINDEX);

		entry->xdsl2LineStatusPwrMngState = lines_stats[linenum].xdsl2LineStatusPwrMngState;
		entry->xdsl2LineStatusAttainableRateDs = lines_stats[linenum].max_down_rate_kbps * 1000;
		entry->xdsl2LineStatusAttainableRateUs = lines_stats[linenum].max_up_rate_kbps * 1000;
		entry->xdsl2LineStatusActAtpDs = dbm_float_to_long(lines_stats[linenum].pwr_dbm[0]);
		entry->xdsl2LineStatusActAtpUs = dbm_float_to_long(lines_stats[linenum].pwr_dbm[1]);

		set_vdsl2_profile_bitmap(lines_stats[linenum].profile, entry->xdsl2LineStatusActProfile);

		entry->xdsl2LineStatusTrellisDs = lines_stats[linenum].trellis[0];
		entry->xdsl2LineStatusTrellisUs = lines_stats[linenum].trellis[1];
	}
}

static long dbm_float_to_long(float pwr_dbm) {
	// Check valid range: -31.0 to 31.0
	if (pwr_dbm < -31.0f || pwr_dbm > 31.0f) {
		return 0x7FFFFFFF; // out-of-range sentinel
	}
	// Convert to tenths of dBm and round properly
	return (long)(pwr_dbm * 10.0f + (pwr_dbm >= 0 ? 0.5f : -0.5f));
}

static int set_vdsl2_profile_bitmap(const char* input, char profile_bitmap[2]) {
	profile_bitmap[0] = 0x00;
	profile_bitmap[1] = 0x00;

	if (input == NULL)
		return 0;
	if (strcmp(input, "8a") == 0) {
		SET_BIT(profile_bitmap, 0);
	}
	else if (strcmp(input, "8b") == 0) {
		SET_BIT(profile_bitmap, 1);
	}
	else if (strcmp(input, "8c") == 0) {
		SET_BIT(profile_bitmap, 2);
	}
	else if (strcmp(input, "8d") == 0) {
		SET_BIT(profile_bitmap, 3);
	}
	else if (strcmp(input, "12a") == 0) {
		SET_BIT(profile_bitmap, 4);
	}
	else if (strcmp(input, "12b") == 0) {
		SET_BIT(profile_bitmap, 5);
	}
	else if (strcmp(input, "17a") == 0) {
		SET_BIT(profile_bitmap, 6);
	}
	else if (strcmp(input, "30a") == 0) {
		SET_BIT(profile_bitmap, 7);
	}
	else if (strcmp(input, "35b") == 0) {
		SET_BIT(profile_bitmap, 8);
	}
	else {
		// Unknown profile string
		return 0;
	}
	return 1;
}

netsnmp_variable_list*
xdsl2LineTable_get_next_data_point(void** my_loop_context,
	void** my_data_context,
	netsnmp_variable_list* put_index_data,
	netsnmp_iterator_info* mydata)
{
	struct xdsl2LineTable_entry* entry = (struct xdsl2LineTable_entry*)*my_loop_context;
	netsnmp_variable_list* idx = put_index_data;

	if (entry) {
		snmp_set_var_typed_integer(idx, ASN_INTEGER, entry->ifIndex);
		idx = idx->next_variable;
		*my_data_context = (void*)entry;
		*my_loop_context = (void*)entry->next;
		return put_index_data;
	}
	else {
		return NULL;
	}
}


/** handles requests for the xdsl2LineTable table */
int
xdsl2LineTable_handler(netsnmp_mib_handler* handler, netsnmp_handler_registration* reginfo, netsnmp_agent_request_info* reqinfo, netsnmp_request_info* requests) {
	netsnmp_request_info* request;
	netsnmp_table_request_info* table_info;
	struct xdsl2LineTable_entry* table_entry;

	DEBUGMSGTL(("xdsl2LineTable:handler", "Processing request (%d)\n", reqinfo->mode));

	switch (reqinfo->mode) {
		/*
		 * Read-support (also covers GetNext requests)
		 */
	case MODE_GET:
		for (request = requests; request; request = request->next) {
			table_entry = (struct xdsl2LineTable_entry*)
				netsnmp_extract_iterator_context(request);
			table_info = netsnmp_extract_table_info(request);

			switch (table_info->colnum) {
			case COLUMN_XDSL2LINECONFTEMPLATE:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request,
						SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
					table_entry->xdsl2LineConfTemplate,
					table_entry->xdsl2LineConfTemplate_len);
				break;
			case COLUMN_XDSL2LINECONFFALLBACKTEMPLATE:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR, table_entry->xdsl2LineConfFallbackTemplate,	table_entry->xdsl2LineConfFallbackTemplate_len);
				break;
			case COLUMN_XDSL2LINEALARMCONFTEMPLATE:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR, table_entry->xdsl2LineAlarmConfTemplate, table_entry->xdsl2LineAlarmConfTemplate_len);
				break;
			case COLUMN_XDSL2LINECMNDCONFPMSF:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER, table_entry->xdsl2LineCmndConfPmsf);
				break;
			case COLUMN_XDSL2LINECMNDCONFLDSF:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER, table_entry->xdsl2LineCmndConfLdsf);
				break;
			case COLUMN_XDSL2LINECMNDCONFLDSFFAILREASON:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER, table_entry->xdsl2LineCmndConfLdsfFailReason);
				break;
			case COLUMN_XDSL2LINECMNDCONFBPSC:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER, table_entry->xdsl2LineCmndConfBpsc);
				break;
			case COLUMN_XDSL2LINECMNDCONFBPSCFAILREASON:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER, table_entry->xdsl2LineCmndConfBpscFailReason);
				break;
			case COLUMN_XDSL2LINECMNDCONFBPSCREQUESTS:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_integer(request->requestvb, ASN_COUNTER, table_entry->xdsl2LineCmndConfBpscRequests);
				break;
			case COLUMN_XDSL2LINECMNDAUTOMODECOLDSTART:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER, table_entry->xdsl2LineCmndAutomodeColdStart);
				break;
			case COLUMN_XDSL2LINECMNDCONFRESET:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
					table_entry->xdsl2LineCmndConfReset);
				break;
			case COLUMN_XDSL2LINESTATUSACTTEMPLATE:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request,
						SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
					table_entry->xdsl2LineStatusActTemplate,
					table_entry->xdsl2LineStatusActTemplate_len);
				break;
			case COLUMN_XDSL2LINESTATUSXTUTRANSSYS:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request,
						SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
					table_entry->xdsl2LineStatusXtuTransSys,
					table_entry->xdsl2LineStatusXtuTransSys_len);
				break;
			case COLUMN_XDSL2LINESTATUSPWRMNGSTATE:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request,
						SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
					table_entry->xdsl2LineStatusPwrMngState);
				break;
			case COLUMN_XDSL2LINESTATUSINITRESULT:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request,
						SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
					table_entry->xdsl2LineStatusInitResult);
				break;
			case COLUMN_XDSL2LINESTATUSLASTSTATEDS:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request,
						SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
					table_entry->xdsl2LineStatusLastStateDs);
				break;
			case COLUMN_XDSL2LINESTATUSLASTSTATEUS:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request,
						SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
					table_entry->xdsl2LineStatusLastStateUs);
				break;
			case COLUMN_XDSL2LINESTATUSXTUR:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request,
						SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
					table_entry->xdsl2LineStatusXtur,
					table_entry->xdsl2LineStatusXtur_len);
				break;
			case COLUMN_XDSL2LINESTATUSXTUC:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request,
						SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
					table_entry->xdsl2LineStatusXtuc,
					table_entry->xdsl2LineStatusXtuc_len);
				break;
			case COLUMN_XDSL2LINESTATUSATTAINABLERATEDS:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request,
						SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_integer(request->requestvb, ASN_UNSIGNED,
					table_entry->xdsl2LineStatusAttainableRateDs);
				break;
			case COLUMN_XDSL2LINESTATUSATTAINABLERATEUS:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request,
						SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_integer(request->requestvb, ASN_UNSIGNED,
					table_entry->xdsl2LineStatusAttainableRateUs);
				break;
			case COLUMN_XDSL2LINESTATUSACTPSDDS:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request,
						SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
					table_entry->xdsl2LineStatusActPsdDs);
				break;
			case COLUMN_XDSL2LINESTATUSACTPSDUS:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request,
						SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
					table_entry->xdsl2LineStatusActPsdUs);
				break;
			case COLUMN_XDSL2LINESTATUSACTATPDS:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request,
						SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
					table_entry->xdsl2LineStatusActAtpDs);
				break;
			case COLUMN_XDSL2LINESTATUSACTATPUS:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request,
						SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
					table_entry->xdsl2LineStatusActAtpUs);
				break;
			case COLUMN_XDSL2LINESTATUSACTPROFILE:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request,
						SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
					table_entry->xdsl2LineStatusActProfile,
					sizeof(table_entry->xdsl2LineStatusActProfile));
				break;
			case COLUMN_XDSL2LINESTATUSACTLIMITMASK:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request,
						SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
					table_entry->xdsl2LineStatusActLimitMask,
					table_entry->xdsl2LineStatusActLimitMask_len);
				break;
			case COLUMN_XDSL2LINESTATUSACTUS0MASK:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request,
						SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
					table_entry->xdsl2LineStatusActUs0Mask,
					table_entry->xdsl2LineStatusActUs0Mask_len);
				break;
			case COLUMN_XDSL2LINESTATUSACTSNRMODEDS:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request,
						SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
					table_entry->xdsl2LineStatusActSnrModeDs);
				break;
			case COLUMN_XDSL2LINESTATUSACTSNRMODEUS:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request,
						SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
					table_entry->xdsl2LineStatusActSnrModeUs);
				break;
			case COLUMN_XDSL2LINESTATUSELECTRICALLENGTH:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request,
						SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_integer(request->requestvb, ASN_UNSIGNED,
					table_entry->xdsl2LineStatusElectricalLength);
				break;
			case COLUMN_XDSL2LINESTATUSTSSIDS:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request,
						SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR, table_entry->xdsl2LineStatusTssiDs, table_entry->xdsl2LineStatusTssiDs_len);
				break;
			case COLUMN_XDSL2LINESTATUSTSSIUS:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request,
						SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR, table_entry->xdsl2LineStatusTssiUs, table_entry->xdsl2LineStatusTssiUs_len);
				break;
			case COLUMN_XDSL2LINESTATUSMREFPSDDS:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request,
						SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
					table_entry->xdsl2LineStatusMrefPsdDs,
					table_entry->xdsl2LineStatusMrefPsdDs_len);
				break;
			case COLUMN_XDSL2LINESTATUSMREFPSDUS:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request,
						SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
					table_entry->xdsl2LineStatusMrefPsdUs,
					table_entry->xdsl2LineStatusMrefPsdUs_len);
				break;
			case COLUMN_XDSL2LINESTATUSTRELLISDS:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request,
						SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
					table_entry->xdsl2LineStatusTrellisDs);
				break;
			case COLUMN_XDSL2LINESTATUSTRELLISUS:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request,
						SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
					table_entry->xdsl2LineStatusTrellisUs);
				break;
			case COLUMN_XDSL2LINESTATUSACTUALCE:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request,
						SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_integer(request->requestvb, ASN_UNSIGNED,
					table_entry->xdsl2LineStatusActualCe);
				break;
			default:
				netsnmp_set_request_error(reqinfo, request,
					SNMP_NOSUCHOBJECT);
				break;
			}
		}
		break;

		/*
		 * Write-support
		 */
	case MODE_SET_RESERVE1:
		for (request = requests; request; request = request->next) {
			table_entry = (struct xdsl2LineTable_entry*)
				netsnmp_extract_iterator_context(request);
			table_info = netsnmp_extract_table_info(request);
			int ret;
			switch (table_info->colnum) {
			case COLUMN_XDSL2LINECONFTEMPLATE:
				/* or possibly 'netsnmp_check_vb_type_and_size' */
				ret = netsnmp_check_vb_type_and_max_size(
					request->requestvb, ASN_OCTET_STR, sizeof(table_entry->xdsl2LineConfTemplate));
				if (ret != SNMP_ERR_NOERROR) {
					netsnmp_set_request_error(reqinfo, request, ret);
					return SNMP_ERR_NOERROR;
				}
				break;
			case COLUMN_XDSL2LINECONFFALLBACKTEMPLATE:
				/* or possibly 'netsnmp_check_vb_type_and_size' */
				ret = netsnmp_check_vb_type_and_max_size(
					request->requestvb, ASN_OCTET_STR, sizeof(table_entry->xdsl2LineConfFallbackTemplate));
				if (ret != SNMP_ERR_NOERROR) {
					netsnmp_set_request_error(reqinfo, request, ret);
					return SNMP_ERR_NOERROR;
				}
				break;
			case COLUMN_XDSL2LINEALARMCONFTEMPLATE:
				/* or possibly 'netsnmp_check_vb_type_and_size' */
				ret = netsnmp_check_vb_type_and_max_size(
					request->requestvb, ASN_OCTET_STR, sizeof(table_entry->xdsl2LineAlarmConfTemplate));
				if (ret != SNMP_ERR_NOERROR) {
					netsnmp_set_request_error(reqinfo, request, ret);
					return SNMP_ERR_NOERROR;
				}
				break;
			case COLUMN_XDSL2LINECMNDCONFPMSF:
				/* or possibly 'netsnmp_check_vb_int_range' */
				ret = netsnmp_check_vb_int(request->requestvb);
				if (ret != SNMP_ERR_NOERROR) {
					netsnmp_set_request_error(reqinfo, request, ret);
					return SNMP_ERR_NOERROR;
				}
				break;
			case COLUMN_XDSL2LINECMNDCONFLDSF:
				/* or possibly 'netsnmp_check_vb_int_range' */
				ret = netsnmp_check_vb_int(request->requestvb);
				if (ret != SNMP_ERR_NOERROR) {
					netsnmp_set_request_error(reqinfo, request, ret);
					return SNMP_ERR_NOERROR;
				}
				break;
			case COLUMN_XDSL2LINECMNDCONFBPSC:
				/* or possibly 'netsnmp_check_vb_int_range' */
				ret = netsnmp_check_vb_int(request->requestvb);
				if (ret != SNMP_ERR_NOERROR) {
					netsnmp_set_request_error(reqinfo, request, ret);
					return SNMP_ERR_NOERROR;
				}
				break;
			case COLUMN_XDSL2LINECMNDAUTOMODECOLDSTART:
				/* or possibly 'netsnmp_check_vb_int_range' */
				ret = netsnmp_check_vb_int(request->requestvb);
				if (ret != SNMP_ERR_NOERROR) {
					netsnmp_set_request_error(reqinfo, request, ret);
					return SNMP_ERR_NOERROR;
				}
				break;
			case COLUMN_XDSL2LINECMNDCONFRESET:
				/* or possibly 'netsnmp_check_vb_int_range' */
				ret = netsnmp_check_vb_int(request->requestvb);
				if (ret != SNMP_ERR_NOERROR) {
					netsnmp_set_request_error(reqinfo, request, ret);
					return SNMP_ERR_NOERROR;
				}
				break;
			default:
				netsnmp_set_request_error(reqinfo, request,
					SNMP_ERR_NOTWRITABLE);
				return SNMP_ERR_NOERROR;
			}
		}
		break;

	case MODE_SET_RESERVE2:
		break;

	case MODE_SET_FREE:
		break;

	case MODE_SET_COMMIT:
		break;
	}
	return SNMP_ERR_NOERROR;
}
